<!doctype html>
<!-- $ make u-config.wasm -->
<title>u-config (WASM)</title>

<style>
body {
    background: #eee;
}
#args {
    display: block;
    font-family: monospace;
    width: 100%;
}
#output {
    background: #fff;
    padding: 0.5em;
}
</style>

<p>
  <label for="files">.pc files:</label>
  <input id="files" type="file" multiple/>
  <button id="clear">clear</button>
  <button id="run">execute</button>
</p>

<p>
  <label for="args">Arguments:</label>
  <input id="args" type="text" value="--help"/>
</p>

<pre id="output"></pre>

<script>
async function uconfig_load() {
    let response = await fetch('u-config.wasm')
    let bytes    = await response.arrayBuffer()
    let module   = await WebAssembly.compile(bytes)

    return function(args, files) {
        // NOTE(skeeto): Throwing from a WASM callback (i.e. abort)
        // corrupts the WebAssembly instance by "leaking" stack. That
        // is, the stack pointer continues from the throw on the next
        // call. So we must create a fresh WASM instance after any such
        // throw. To keep it simple, just create a fresh instance each
        // run despite u-config being more than capable of resetting
        // itself.
        //
        // I cannot find any way to reset the WASM instance, or a method
        // to cleanly non-locally jump. This appears to be one of many
        // limitations of LLVM/Clang's WASM toolchain.

        let output  = [null, "", ""]
        let memory  = null
        let imports = {
            env: {
                abort: function() {
                    throw output[2]
                },
                write: function(fd, ptr, len) {
                    // FIXME: codepoints might straddle writes
                    let utf8 = new Uint8Array(memory.buffer, ptr, len)
                    let str  = new TextDecoder().decode(utf8)
                    output[fd] += str
                }
            }
        }
        let instance = new WebAssembly.Instance(module, imports)
        let exports  = instance.exports
        memory = new DataView(exports.memory.buffer)

        function pushstring(s) {
            let utf8 = new TextEncoder().encode(s)
            let s8   = exports.pushstring(utf8.length)
            let ptr  = memory.getInt32(s8, true)
            for (let i = 0; i < utf8.length; i++) {
                memory.setUint8(ptr+i, utf8[i])
            }
            return s8
        }

        exports.initialize()

        for (let [name, data] of Object.entries(files)) {
            let s8path = pushstring(name)
            let s8data = pushstring(data)
            exports.pushfile(s8path, s8data)
        }

        exports.pushargs(args.length)
        for (let arg of args) {
            exports.pusharg(pushstring(arg))
        }

        exports.uconfig()
        return output[1]
    }
}

async function main() {
    let uconfig = await uconfig_load();
    let filesys = {}
    let output  = document.querySelector("#output")
    let args    = document.querySelector("#args")
    let files   = document.querySelector("#files")
    let run     = document.querySelector("#run")
    let clear   = document.querySelector("#clear")

    function execute() {
        try {
            let argv = args.value.split(/ +/)
            output.textContent = uconfig(argv, filesys)
        } catch (error) {
            output.textContent = error
        }
    }

    clear.addEventListener("click", function() {
        filesys = {}
        execute()
    })
    run.addEventListener("click", execute)
    args.addEventListener("change", execute)
    args.addEventListener("paste", execute)
    args.addEventListener("input", execute)
    files.addEventListener("change", function(e) {
        for (let i = 0; i < files.files.length; i++) {
            let file = files.files[i]
            let name = file.name
            let reader = new FileReader()
            reader.onload = function() {
                filesys[name] = reader.result
                execute()
            }
            reader.readAsText(file)
        }
    })

    execute()
}

main()
</script>
